<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ°´ç­çŸ¿å·¥ï¼šæé™é€»è¾‘ç‰ˆ</title>
    <style>
        body { margin: 0; padding: 0; background: #1a1a1a; font-family: sans-serif; touch-action: none; overflow: hidden; }
        canvas { display: block; background: radial-gradient(circle, #8b4513 0%, #4d260b 100%); margin: 0 auto; }
        #ui { 
            position: absolute; top: 15px; left: 15px; color: #f1c40f; 
            font-size: 20px; font-weight: bold; pointer-events: none;
            text-shadow: 2px 2px 4px #000; line-height: 1.5;
        }
    </style>
</head>
<body>
    <div id="ui">
        ç¬¬ <span id="level">1</span> å…³<br>
        å¾—åˆ†: <span id="score">0</span>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const levelEl = document.getElementById('level');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// æ¸¸æˆæ ¸å¿ƒå˜é‡
let score = 0;
let currentLevel = 1;
let angle = 0;
let direction = 1;
let hookState = "swing"; 
let hookLen = 50;
let currentItem = null; 
let isExploding = false; // ç‚¸å¼¹åŠ¨ç”»çŠ¶æ€

const originX = canvas.width / 2;
const originY = 70;
let baseSpeed = 8; 
let swingSpeed = 0.04; // éšå…³å¡å¢åŠ 

let items = [];

// åˆå§‹åŒ–å…³å¡é€»è¾‘
function initLevel(level) {
    items = [];
    hookState = "swing";
    hookLen = 50;
    // éš¾åº¦é€’å¢ï¼šæ‘†åŠ¨å˜å¿«ï¼Œç‰©ä½“å˜å¤š
    swingSpeed = 0.04 + (level * 0.005);
    let goldCount = 5; // å¿…é¡»æŠ“å®Œçš„ç›®æ ‡
    let stoneCount = 3 + level;
    let bombCount = Math.min(level, 5); // ç‚¸å¼¹éšå…³å¡å¢å¤š

    // ç”Ÿæˆé»„é‡‘
    for(let i=0; i<goldCount; i++) createObject("gold");
    // ç”ŸæˆçŸ³å¤´
    for(let i=0; i<stoneCount; i++) createObject("stone");
    // ç”Ÿæˆç‚¸å¼¹
    for(let i=0; i<bombCount; i++) createObject("bomb");
}

function createObject(type) {
    let size = type === "gold" ? Math.random()*30+25 : (type === "stone" ? Math.random()*40+20 : 35);
    items.push({
        x: Math.random() * (canvas.width - 80) + 40,
        y: Math.random() * (canvas.height - 300) + 200,
        r: size,
        type: type,
        weight: type === "stone" ? size * 0.4 : (type === "gold" ? size * 0.15 : 0.1),
        val: type === "gold" ? Math.floor(size * 3) : (type === "stone" ? -Math.floor(size) : 0)
    });
}

function update() {
    // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰é»„é‡‘ï¼Œæ²¡æœ‰åˆ™è‡ªåŠ¨ä¸‹ä¸€å…³
    const goldLeft = items.find(i => i.type === "gold");
    if (!goldLeft && !currentItem && hookState === "swing") {
        currentLevel++;
        levelEl.innerText = currentLevel;
        initLevel(currentLevel);
        return;
    }

    if (hookState === "swing") {
        angle += swingSpeed * direction;
        if (Math.abs(angle) > 1.35) direction *= -1;
    } 
    else if (hookState === "extend") {
        hookLen += baseSpeed;
        if (hookLen > canvas.height - 50) hookState = "retract";
        
        let hX = originX + Math.sin(angle) * hookLen;
        let hY = originY + Math.cos(angle) * hookLen;

        for (let i = 0; i < items.length; i++) {
            let item = items[i];
            let dx = hX - item.x;
            let dy = hY - item.y;
            if (Math.sqrt(dx*dx + dy*dy) < item.r) {
                // ç¢°åˆ°ç‚¸å¼¹é€»è¾‘
                if (item.type === "bomb") {
                    items.splice(i, 1);
                    isExploding = true;
                    setTimeout(() => isExploding = false, 500);
                    hookState = "retract"; // ç«‹å³ç¼©å›
                    return;
                }
                currentItem = items.splice(i, 1)[0];
                hookState = "retract";
                break; 
            }
        }
    } 
    else if (hookState === "retract") {
        let speedReduce = currentItem ? currentItem.weight : (isExploding ? -10 : 0);
        hookLen -= Math.max(2, baseSpeed - speedReduce); 

        if (hookLen <= 50) {
            if (currentItem) {
                score += currentItem.val;
                scoreEl.innerText = score;
                currentItem = null;
            }
            hookLen = 50;
            hookState = "swing";
        }
    }
}

function drawItem(item) {
    ctx.save();
    ctx.shadowBlur = 10;
    ctx.shadowColor = "rgba(0,0,0,0.3)";
    ctx.font = `${item.r * 1.3}px serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    let emoji = "ğŸ’°";
    if (item.type === "stone") emoji = "ğŸª¨";
    if (item.type === "bomb") emoji = "ğŸ’£";
    ctx.fillText(emoji, item.x, item.y);
    ctx.restore();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // æ°´ç­
    ctx.font = "60px serif";
    ctx.textAlign = "center";
    ctx.fillText("ğŸ¦¦", originX, originY);
    
    let hX = originX + Math.sin(angle) * hookLen;
    let hY = originY + Math.cos(angle) * hookLen;
    
    // ç»³ç´¢
    ctx.beginPath();
    ctx.moveTo(originX, originY + 15);
    ctx.lineTo(hX, hY);
    ctx.strokeStyle = isExploding ? "orange" : "#d35400";
    ctx.lineWidth = isExploding ? 8 : 3;
    ctx.stroke();

    // ç‚¸å¼¹ç‰¹æ•ˆ
    if (isExploding) {
        ctx.font = "80px serif";
        ctx.fillText("ğŸ’¥", hX, hY);
    }

    if (currentItem) {
        currentItem.x = hX;
        currentItem.y = hY + (currentItem.r * 0.4);
        drawItem(currentItem);
    }

    items.forEach(drawItem);
    update();
    requestAnimationFrame(draw);
}

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (hookState === "swing") hookState = "extend";
}, {passive: false});

// ç«‹å³æ‰§è¡Œåˆå§‹åŒ–
initLevel(currentLevel);
draw();
</script>
</body>
</html>
